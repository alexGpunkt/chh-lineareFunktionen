<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìê Lineare Funktionen ¬∑ PRO</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg: #0c0f1c;
            --card: #1b2235;
            --card-border: #2a3450;
            --accent: #5abfff;
            --accent-soft: rgba(90, 190, 255, 0.2);
            --text: #eef3ff;
            --text-dim: #a5b3d9;
            --success: #6fcf97;
            --success-soft: rgba(111, 207, 151, 0.1);
            --error: #eb5757;
            --error-soft: rgba(235, 87, 87, 0.1);
            --warning: #f2c94c;
            --warning-soft: rgba(242, 201, 76, 0.1);
            --radius: 20px;
            --radius-sm: 40px;
            --transition: all 0.2s ease;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.5;
            padding: 1.5rem;
            min-height: 100vh;
        }

        .app {
            max-width: 1400px;
            margin: 0 auto;
            background: #111726;
            border-radius: var(--radius);
            padding: 2rem;
            border: 1px solid var(--card-border);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .header h2 {
            font-weight: 500;
            letter-spacing: -0.01em;
        }

        .qr-btn {
            background: transparent;
            border: 1px solid var(--accent);
            padding: 0.5rem 1.2rem;
            border-radius: var(--radius-sm);
            color: white;
            cursor: pointer;
            font-size: 0.95rem;
            transition: var(--transition);
        }

        .qr-btn:hover {
            background: var(--accent-soft);
            transform: translateY(-1px);
        }

        /* Navigation */
        .topbar {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 2rem;
        }

        .nav-btn {
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-dim);
            padding: 0.6rem 1.2rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.95rem;
            transition: var(--transition);
            white-space: nowrap;
        }

        .nav-btn:hover {
            border-color: var(--accent);
            color: white;
        }

        .nav-btn.active {
            border-color: var(--accent);
            background: var(--accent-soft);
            color: white;
            font-weight: 500;
        }

        /* Hauptbereich */
        .main {
            display: grid;
            grid-template-columns: 1.2fr 0.8fr;
            gap: 2rem;
        }

        @media (max-width: 1000px) {
            .main {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--card);
            padding: 1.8rem;
            border-radius: var(--radius);
            border: 1px solid var(--card-border);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        /* SVG Container */
        .svg-container {
            background: #0f1423;
            border-radius: 16px;
            padding: 0.5rem;
            margin-bottom: 1.5rem;
        }

        svg {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 12px;
        }

        /* Multi-Graph Layout */
        .graph-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .graph-option {
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid transparent;
            border-radius: 16px;
            padding: 0.5rem;
        }

        .graph-option:hover {
            background: rgba(90, 190, 255, 0.1);
        }

        .graph-option.selected {
            border-color: var(--accent);
            background: var(--accent-soft);
        }

        .graph-option.correct {
            border-color: var(--success);
            background: var(--success-soft);
        }

        .graph-option.wrong {
            border-color: var(--error);
            background: var(--error-soft);
        }

        /* Erkl√§rungen */
        .explanation {
            margin-top: 1.2rem;
            font-size: 0.95rem;
            color: var(--text-dim);
        }

        .explanation b {
            color: var(--text);
            font-weight: 600;
        }

        .steps {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #cfd9ff;
            list-style: none;
            counter-reset: step-counter;
        }

        .steps li {
            margin-bottom: 0.5rem;
            counter-increment: step-counter;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .steps li::before {
            content: counter(step-counter) "Ô∏è‚É£";
            opacity: 0.8;
            font-size: 0.9rem;
        }

        .chip {
            display: inline-block;
            background: var(--accent-soft);
            padding: 0.3rem 0.8rem;
            border-radius: var(--radius-sm);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.9rem;
            border: 1px solid var(--accent);
        }

        .equation {
            font-size: 1.3rem;
            text-align: center;
            padding: 1rem;
            background: #0f1423;
            border-radius: var(--radius);
            margin-bottom: 1rem;
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        /* Formularelemente */
        .input-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
            margin-bottom: 1rem;
        }

        .step-group {
            background: #0f1423;
            padding: 1rem;
            border-radius: var(--radius);
            margin-bottom: 1rem;
            border: 1px solid var(--card-border);
        }

        .step-label {
            color: var(--accent);
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input {
            background: #0f1423;
            border: 1px solid var(--card-border);
            padding: 0.6rem 1.2rem;
            border-radius: var(--radius-sm);
            color: white;
            font-size: 0.95rem;
            transition: var(--transition);
            width: 130px;
        }

        input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent-soft);
        }

        input::placeholder {
            color: #4a5670;
        }

        .input-correct {
            border-color: var(--success);
            background: var(--success-soft);
        }

        .input-wrong {
            border-color: var(--error);
            background: var(--error-soft);
        }

        .button-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin: 1.2rem 0 0.8rem;
        }

        button {
            background: var(--accent-soft);
            border: 1px solid var(--accent);
            padding: 0.6rem 1.2rem;
            border-radius: var(--radius-sm);
            color: white;
            cursor: pointer;
            font-size: 0.95rem;
            transition: var(--transition);
            flex: 0 1 auto;
        }

        button:hover {
            background: rgba(90, 190, 255, 0.3);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            border-color: var(--text-dim);
            background: transparent;
        }

        button.secondary:hover {
            border-color: white;
            background: rgba(255, 255, 255, 0.05);
        }

        /* Feedback */
        .feedback {
            margin-top: 1.2rem;
            padding: 0.8rem 1.2rem;
            border-left: 4px solid var(--accent);
            border-radius: 12px;
            background: rgba(90, 190, 255, 0.05);
            font-weight: 500;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .feedback.success {
            border-left-color: var(--success);
            background: var(--success-soft);
            color: #d0f0da;
        }

        .feedback.error {
            border-left-color: var(--error);
            background: var(--error-soft);
            color: #f5c2c2;
        }

        .feedback.warning {
            border-left-color: var(--warning);
            background: var(--warning-soft);
            color: #f9e2b7;
        }

        /* Tabelle */
        .table-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .table-label {
            min-width: 40px;
            color: var(--text-dim);
            font-family: monospace;
        }

        /* QR Overlay */
        .qr-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .qr-box {
            background: var(--card);
            padding: 2.5rem;
            border-radius: var(--radius);
            text-align: center;
            border: 1px solid var(--card-border);
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.5);
            max-width: 400px;
            width: 90%;
        }

        .qr-box h3 {
            margin-bottom: 1.5rem;
            color: var(--accent);
        }

        .qr-box img {
            margin: 1.5rem 0;
            border-radius: 12px;
            background: white;
            padding: 0.5rem;
            max-width: 100%;
            height: auto;
        }

        /* Utilities */
        .hidden {
            display: none !important;
        }

        .mt-2 {
            margin-top: 0.75rem;
        }

        .text-center {
            text-align: center;
        }

        .hint {
            font-size: 0.9rem;
            color: var(--text-dim);
            font-style: italic;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
<div class="app">
    <div class="header">
        <h2>üìê Lineare Funktionen ¬∑ PRO</h2>
        <button class="qr-btn hidden" id="qrButton">üì± QR-Code</button>
    </div>

    <div class="topbar">
        <button class="nav-btn active" data-section="coords">üìå Punkte</button>
        <button class="nav-btn" data-section="table">üìä Tabelle</button>
        <button class="nav-btn" data-section="normal">üìà m & b</button>
        <button class="nav-btn" data-section="parallel">‚ö° Parallel</button>
        <button class="nav-btn" data-section="graph">üìâ Graph w√§hlen</button>
        <button class="nav-btn" data-section="zero">üéØ Nullstellen</button>
    </div>

    <div class="main">
        <div class="card" id="graphCard"></div>
        <div class="card" id="exerciseCard"></div>
    </div>
</div>

<div id="qrOverlay" class="qr-overlay hidden">
    <div class="qr-box">
        <h3>üì± Auf Smartphone √∂ffnen</h3>
        <img id="qrImage" alt="QR-Code">
        <div class="button-group" style="justify-content: center;">
            <button onclick="closeQR()">Schlie√üen</button>
        </div>
    </div>
</div>

<script>
    (function() {
        'use strict';

        // ==================== KONSTANTEN & HILFSFUNKTIONEN ====================
        const SVG_BOUNDS = { min: -6, max: 6 };
        const EPSILON = 0.01;

        const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        
        const randomSlope = () => {
            let m;
            do {
                m = randomInt(-4, 4);
            } while (Math.abs(m) < EPSILON);
            return m;
        };

        const randomSlopeWithZero = () => {
            return randomInt(-4, 4);
        };

        const parseInput = (val) => {
            if (!val) return NaN;
            const str = val.replace(/,/g, '.').trim();
            
            // Bruch parsing
            if (str.includes('/')) {
                const parts = str.split('/').map(Number);
                if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1]) && Math.abs(parts[1]) > EPSILON) {
                    return parts[0] / parts[1];
                }
            }
            
            const num = parseFloat(str);
            return isNaN(num) ? NaN : num;
        };

        const formatNumber = (num) => {
            if (Math.abs(num - Math.round(num)) < EPSILON) {
                return Math.round(num).toString();
            }
            return num.toFixed(2).replace(/\.?0+$/, '');
        };

        // ==================== SVG RENDERING ====================
        const clipLine = (m, b) => {
            const { min: xMin, max: xMax } = SVG_BOUNDS;
            const yMin = xMin, yMax = xMax;
            const points = [];
            
            const addPoint = (x, y) => {
                if (x >= xMin - EPSILON && x <= xMax + EPSILON && 
                    y >= yMin - EPSILON && y <= yMax + EPSILON) {
                    points.push({ x: Math.max(xMin, Math.min(xMax, x)), 
                                 y: Math.max(yMin, Math.min(yMax, y)) });
                }
            };

            addPoint(xMin, m * xMin + b);
            addPoint(xMax, m * xMax + b);

            if (Math.abs(m) > EPSILON) {
                addPoint((yMin - b) / m, yMin);
                addPoint((yMax - b) / m, yMax);
            }

            return points.slice(0, 2);
        };

        const renderSingleGraph = (m, b, options = {}) => {
            const { triangle = false, highlight = null, color = '#5abfff' } = options;
            const { min, max } = SVG_BOUNDS;
            const range = max - min;
            
            let gridLines = '';
            
            for (let x = min; x <= max; x++) {
                if (x === 0) continue;
                gridLines += `<line x1="${x}" y1="${min}" x2="${x}" y2="${max}" stroke="#2a3450" stroke-width="0.05"/>`;
            }
            for (let y = min; y <= max; y++) {
                if (y === 0) continue;
                gridLines += `<line x1="${min}" y1="${y}" x2="${max}" y2="${y}" stroke="#2a3450" stroke-width="0.05"/>`;
            }

            const axes = `
                <line x1="${min}" y1="0" x2="${max}" y2="0" stroke="#5abfff" stroke-width="0.12"/>
                <line x1="0" y1="${min}" x2="0" y2="${max}" stroke="#5abfff" stroke-width="0.12"/>
            `;

            let functionLine = '';
            if (m !== null && !isNaN(m) && !isNaN(b)) {
                const segment = clipLine(m, b);
                if (segment.length === 2) {
                    functionLine = `<line x1="${segment[0].x}" y1="${segment[0].y}" 
                                           x2="${segment[1].x}" y2="${segment[1].y}" 
                                           stroke="${color}" stroke-width="0.2" stroke-linecap="round"/>`;
                }
            }

            let triangleMark = '';
            if (triangle && m !== null && !isNaN(m) && !isNaN(b) && Math.abs(m) < 10) {
                const run = 1;
                const rise = m;
                const p1 = { x: 0, y: b };
                const p2 = { x: run, y: b };
                const p3 = { x: run, y: b + rise };
                
                if (Math.abs(p1.x) <= max && Math.abs(p1.y) <= max &&
                    Math.abs(p2.x) <= max && Math.abs(p2.y) <= max &&
                    Math.abs(p3.x) <= max && Math.abs(p3.y) <= max) {
                    triangleMark = `
                        <polygon points="${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}"
                                 fill="rgba(90,190,255,0.2)" stroke="#5abfff" stroke-width="0.1" stroke-dasharray="0.2"/>
                    `;
                }
            }

            let highlightMark = '';
            if (highlight) {
                highlightMark = `<circle cx="${highlight.x}" cy="${highlight.y}" r="0.35" fill="#eb5757" stroke="white" stroke-width="0.1"/>`;
            }

            let labels = '';
            for (let i = min; i <= max; i++) {
                if (i === 0) continue;
                labels += `<text x="${i - 0.2}" y="-0.2" fill="#6b7b9c" font-size="0.3">${i}</text>`;
                labels += `<text x="-0.4" y="${i + 0.1}" fill="#6b7b9c" font-size="0.3">${-i}</text>`;
            }

            return `
                <svg viewBox="${min} ${min} ${range} ${range}" xmlns="http://www.w3.org/2000/svg">
                    ${gridLines}
                    ${axes}
                    ${labels}
                    ${functionLine}
                    ${triangleMark}
                    ${highlightMark}
                </svg>
            `;
        };

        const renderGraphOptions = (functions, selectedIndex = -1, correctIndex = null) => {
            const { min, max } = SVG_BOUNDS;
            const range = max - min;
            
            return functions.map((f, idx) => {
                const isSelected = idx === selectedIndex;
                const isCorrect = correctIndex !== null && idx === correctIndex;
                const isWrong = selectedIndex !== -1 && isSelected && correctIndex !== null && idx !== correctIndex;
                
                let containerClass = 'graph-option';
                if (isSelected) containerClass += ' selected';
                if (isCorrect) containerClass += ' correct';
                if (isWrong) containerClass += ' wrong';
                
                let gridLines = '';
                for (let x = min; x <= max; x++) {
                    if (x === 0) continue;
                    gridLines += `<line x1="${x}" y1="${min}" x2="${x}" y2="${max}" stroke="#2a3450" stroke-width="0.03"/>`;
                }
                for (let y = min; y <= max; y++) {
                    if (y === 0) continue;
                    gridLines += `<line x1="${min}" y1="${y}" x2="${max}" y2="${y}" stroke="#2a3450" stroke-width="0.03"/>`;
                }

                const axes = `
                    <line x1="${min}" y1="0" x2="${max}" y2="0" stroke="#5abfff" stroke-width="0.08"/>
                    <line x1="0" y1="${min}" x2="0" y2="${max}" stroke="#5abfff" stroke-width="0.08"/>
                `;

                const segment = clipLine(f.m, f.b);
                let functionLine = '';
                if (segment.length === 2) {
                    functionLine = `<line x1="${segment[0].x}" y1="${segment[0].y}" 
                                           x2="${segment[1].x}" y2="${segment[1].y}" 
                                           stroke="#5abfff" stroke-width="0.15" stroke-linecap="round"/>`;
                }

                return `
                    <div class="${containerClass}" data-graph-index="${idx}">
                        <svg viewBox="${min} ${min} ${range} ${range}" xmlns="http://www.w3.org/2000/svg">
                            ${gridLines}
                            ${axes}
                            ${functionLine}
                        </svg>
                    </div>
                `;
            }).join('');
        };

        // ==================== APP STATE ====================
        let currentSection = 'coords';
        let currentExample = {};
        let feedbackElement = null;
        let selectedGraphIndex = -1;
        let showGraphSolution = false;

        // ==================== BEISPIELE GENERIEREN ====================
        const generateExample = () => {
            selectedGraphIndex = -1;
            showGraphSolution = false;
            
            switch (currentSection) {
                case 'coords':
                    currentExample = {
                        target: {
                            x: randomInt(-5, 5),
                            y: randomInt(-5, 5)
                        }
                    };
                    break;

                case 'table':
                    currentExample = {
                        m: randomSlope(),
                        b: randomInt(-4, 4),
                        xs: [-2, -1, 0, 1, 2]
                    };
                    break;

                case 'normal':
                    currentExample = {
                        m: randomSlope(),
                        b: randomInt(-4, 4)
                    };
                    break;

                case 'parallel':
                    const m = randomSlope();
                    const b = randomInt(-4, 4);
                    const P = {
                        x: randomInt(-3, 3),
                        y: randomInt(-3, 3)
                    };
                    const mPerp = (Math.abs(m) < EPSILON) ? 1000 : -1 / m;
                    
                    currentExample = {
                        m, b, P,
                        mPerp,
                        bPar: P.y - m * P.x,
                        bPerp: P.y - mPerp * P.x
                    };
                    break;

                case 'graph':
                    // Funktion f√ºr die gesucht wird
                    const targetM = randomSlopeWithZero();
                    const targetB = randomInt(-4, 4);
                    
                    // 4 verschiedene Graphen generieren
                    const options = [
                        { m: targetM, b: targetB }, // Korrekte L√∂sung
                        { m: targetM, b: randomInt(-4, 4) }, // Gleiche Steigung, anderer b
                        { m: randomSlopeWithZero(), b: targetB }, // Andere Steigung, gleicher b
                        { m: randomSlopeWithZero(), b: randomInt(-4, 4) } // Komplett anders
                    ];
                    
                    // Sicherstellen, dass alle Optionen unterschiedlich sind
                    const uniqueOptions = [];
                    options.forEach(opt => {
                        const exists = uniqueOptions.some(u => 
                            Math.abs(u.m - opt.m) < EPSILON && Math.abs(u.b - opt.b) < EPSILON
                        );
                        if (!exists) uniqueOptions.push(opt);
                    });
                    
                    // Falls n√∂tig, auff√ºllen
                    while (uniqueOptions.length < 4) {
                        uniqueOptions.push({
                            m: randomSlopeWithZero(),
                            b: randomInt(-4, 4)
                        });
                    }
                    
                    currentExample = {
                        targetM,
                        targetB,
                        options: uniqueOptions.slice(0, 4),
                        correctIndex: 0 // Erste Option ist immer die korrekte
                    };
                    break;

                case 'zero':
                    const zeroM = randomSlope(); // Nicht null, damit es eine Nullstelle gibt
                    const zeroB = randomInt(-4, 4);
                    const zeroX = -zeroB / zeroM;
                    
                    currentExample = {
                        m: zeroM,
                        b: zeroB,
                        zero: zeroX,
                        steps: [
                            { description: '0 = m¬∑x + b', operation: 'Null setzen' },
                            { description: `0 = ${formatNumber(zeroM)}¬∑x + ${formatNumber(zeroB)}`, operation: 'Einsetzen' },
                            { description: `${-zeroB} = ${formatNumber(zeroM)}¬∑x`, operation: 'b auf beide Seiten' },
                            { description: `x = ${formatNumber(zeroX)}`, operation: 'Durch m teilen' }
                        ]
                    };
                    break;
            }
        };

        // ==================== UI RENDERING ====================
        const renderSection = () => {
            const graphCard = document.getElementById('graphCard');
            const exerciseCard = document.getElementById('exerciseCard');
            
            if (!graphCard || !exerciseCard) return;

            let graphHTML = '';
            let exerciseHTML = '';

            switch (currentSection) {
                case 'coords':
                    graphHTML = renderSingleGraph(null, null, { highlight: currentExample.target });
                    graphHTML += `
                        <div class="explanation">
                            <b>üìå Punkt im Koordinatensystem</b>
                            <p>Koordinaten: (x | y) ‚Äî zuerst x, dann y.</p>
                            <ul class="steps">
                                <li>Vom Ursprung starten</li>
                                <li>Nach rechts/links (x)</li>
                                <li>Nach oben/unten (y)</li>
                            </ul>
                        </div>
                    `;

                    exerciseHTML = `
                        <div class="equation">Punkt gesucht</div>
                        <div class="input-group">
                            <input id="coordsInput" placeholder="x, y" autocomplete="off">
                        </div>
                        <div class="button-group">
                            <button onclick="checkCoords()">‚úì Pr√ºfen</button>
                            <button class="secondary" onclick="newExample()">‚Üª Neu</button>
                        </div>
                        <div class="feedback" id="feedback"></div>
                    `;
                    break;

                case 'table':
                    graphHTML = renderSingleGraph(currentExample.m, currentExample.b);
                    graphHTML += `
                        <div class="explanation">
                            <b>üìä Wertetabelle</b>
                            <p>Formel: <span class="chip">y = ${formatNumber(currentExample.m)}¬∑x + ${formatNumber(currentExample.b)}</span></p>
                            <ul class="steps">
                                <li>x einsetzen</li>
                                <li>m¬∑x berechnen</li>
                                <li>b addieren</li>
                            </ul>
                        </div>
                    `;

                    exerciseHTML = '<div style="margin-bottom: 1rem;">';
                    currentExample.xs.forEach((x, i) => {
                        exerciseHTML += `
                            <div class="table-row">
                                <span class="table-label">x = ${x}</span>
                                <input id="t${i}" placeholder="y" autocomplete="off">
                            </div>
                        `;
                    });
                    exerciseHTML += `</div>
                        <div class="button-group">
                            <button onclick="checkTable()">‚úì Pr√ºfen</button>
                            <button class="secondary" onclick="newExample()">‚Üª Neu</button>
                        </div>
                        <div class="feedback" id="feedback"></div>
                    `;
                    break;

                case 'normal':
                    graphHTML = renderSingleGraph(currentExample.m, currentExample.b, { triangle: true });
                    graphHTML += `
                        <div class="explanation">
                            <b>üìà Steigung & Achsenabschnitt</b>
                            <p><span class="chip">b</span> = Schnittpunkt mit y-Achse</p>
                            <p><span class="chip">m</span> = Anstieg (Œîy / Œîx)</p>
                        </div>
                    `;

                    exerciseHTML = `
                        <div class="equation">y = ${formatNumber(currentExample.m)}¬∑x + ${formatNumber(currentExample.b)}</div>
                        <div class="input-group">
                            <input id="mInput" placeholder="m" autocomplete="off">
                            <input id="bInput" placeholder="b" autocomplete="off">
                        </div>
                        <div class="button-group">
                            <button onclick="checkNormal()">‚úì Pr√ºfen</button>
                            <button class="secondary" onclick="newExample()">‚Üª Neu</button>
                        </div>
                        <div class="feedback" id="feedback"></div>
                    `;
                    break;

                case 'parallel':
                    graphHTML = renderSingleGraph(currentExample.m, currentExample.b, { highlight: currentExample.P });
                    graphHTML += `
                        <div class="explanation">
                            <b>‚ö° Parallele & Senkrechte</b>
                            <p>Parallel: gleiche Steigung m</p>
                            <p>Senkrecht: m‚ÇÅ ¬∑ m‚ÇÇ = -1</p>
                            <p>Punkt P (rot) liegt auf beiden Geraden</p>
                        </div>
                    `;

                    exerciseHTML = `
                        <div class="equation">y = ${formatNumber(currentExample.m)}¬∑x + ${formatNumber(currentExample.b)}</div>
                        <div class="equation" style="font-size:1rem;">P (${currentExample.P.x} | ${currentExample.P.y})</div>
                        <div style="margin-bottom: 1rem;">
                            <div class="input-group">
                                <span style="min-width: 80px;">Parallel m:</span>
                                <input id="pm" placeholder="m" autocomplete="off">
                            </div>
                            <div class="input-group">
                                <span style="min-width: 80px;">Parallel b:</span>
                                <input id="pb" placeholder="b" autocomplete="off">
                            </div>
                            <div class="input-group mt-2">
                                <span style="min-width: 80px;">Senkrecht m:</span>
                                <input id="sm" placeholder="m" autocomplete="off">
                            </div>
                            <div class="input-group">
                                <span style="min-width: 80px;">Senkrecht b:</span>
                                <input id="sb" placeholder="b" autocomplete="off">
                            </div>
                        </div>
                        <div class="button-group">
                            <button onclick="checkParallel()">‚úì Pr√ºfen</button>
                            <button class="secondary" onclick="newExample()">‚Üª Neu</button>
                        </div>
                        <div class="feedback" id="feedback"></div>
                    `;
                    break;

                case 'graph':
                    graphHTML = `
                        <div class="svg-container">
                            <div class="graph-grid">
                                ${renderGraphOptions(currentExample.options, selectedGraphIndex, showGraphSolution ? currentExample.correctIndex : null)}
                            </div>
                        </div>
                        <div class="explanation">
                            <b>üìâ Welcher Graph passt?</b>
                            <p>Gesucht ist die Funktion:</p>
                            <div class="equation">y = ${formatNumber(currentExample.targetM)}¬∑x + ${formatNumber(currentExample.targetB)}</div>
                            <ul class="steps">
                                <li>y-Achsenabschnitt b suchen</li>
                                <li>Steigung m pr√ºfen</li>
                                <li>Passenden Graphen w√§hlen</li>
                            </ul>
                        </div>
                    `;

                    exerciseHTML = `
                        <div class="button-group">
                            <button onclick="checkGraphSelection()" ${selectedGraphIndex === -1 ? 'disabled style="opacity:0.5;"' : ''}>‚úì Auswahl pr√ºfen</button>
                            <button class="secondary" onclick="showGraphSolution = false; newExample()">‚Üª Neu</button>
                        </div>
                        <div class="feedback" id="feedback"></div>
                        <p class="hint">Klicke auf einen Graphen, um ihn auszuw√§hlen.</p>
                    `;
                    break;

                case 'zero':
                    const steps = currentExample.steps || [];
                    
                    graphHTML = renderSingleGraph(currentExample.m, currentExample.b, { 
                        highlight: { x: currentExample.zero, y: 0 }
                    });
                    graphHTML += `
                        <div class="explanation">
                            <b>üéØ Nullstellen berechnen</b>
                            <p>Eine Nullstelle ist der x-Wert, bei dem y = 0 ist.</p>
                            <ul class="steps">
                                <li>Funktion gleich Null setzen</li>
                                <li>Nach x aufl√∂sen</li>
                                <li>Ergebnis ist die Nullstelle</li>
                            </ul>
                        </div>
                    `;

                    exerciseHTML = `
                        <div class="equation">y = ${formatNumber(currentExample.m)}¬∑x + ${formatNumber(currentExample.b)}</div>
                        <div class="step-group">
                            <div class="step-label">Schritt 1: Gleichung aufstellen</div>
                            <input id="step1" placeholder="0 = ..." autocomplete="off" value="0 = ${formatNumber(currentExample.m)}¬∑x + ${formatNumber(currentExample.b)}">
                        </div>
                        <div class="step-group">
                            <div class="step-label">Schritt 2: Nach x aufl√∂sen</div>
                            <input id="step2" placeholder="x = ..." autocomplete="off">
                        </div>
                        <div class="hint">Tipp: Bringe zuerst b auf die andere Seite, dann teile durch m.</div>
                        <div class="button-group">
                            <button onclick="checkZeroSteps()">‚úì Schritte pr√ºfen</button>
                            <button class="secondary" onclick="newExample()">‚Üª Neu</button>
                            <button class="secondary" onclick="showZeroSolution()">üîç L√∂sung anzeigen</button>
                        </div>
                        <div class="feedback" id="feedback"></div>
                    `;
                    break;
            }

            graphCard.innerHTML = graphHTML;
            exerciseCard.innerHTML = exerciseHTML;
            feedbackElement = document.getElementById('feedback');

            // Event-Listener f√ºr Graph-Auswahl
            if (currentSection === 'graph') {
                document.querySelectorAll('.graph-option').forEach(opt => {
                    opt.addEventListener('click', (e) => {
                        if (showGraphSolution) return; // Keine Auswahl mehr nach L√∂sung
                        const idx = parseInt(opt.dataset.graphIndex);
                        selectGraph(idx);
                    });
                });
            }
        };

        // ==================== PR√úFFUNKTIONEN ====================
        window.selectGraph = (index) => {
            selectedGraphIndex = index;
            renderSection();
        };

        window.checkCoords = () => {
            const input = document.getElementById('coordsInput');
            if (!input || !feedbackElement) return;
            
            const parts = input.value.split(',').map(Number);
            const isValid = parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1]);
            
            if (isValid && parts[0] === currentExample.target.x && parts[1] === currentExample.target.y) {
                feedbackElement.textContent = '‚úÖ Richtig! Gut gemacht!';
                feedbackElement.className = 'feedback success';
            } else {
                feedbackElement.textContent = `‚ùå Gesucht war (${currentExample.target.x} | ${currentExample.target.y})`;
                feedbackElement.className = 'feedback error';
            }
        };

        window.checkTable = () => {
            if (!feedbackElement || !currentExample.xs) return;
            
            let allCorrect = true;
            currentExample.xs.forEach((x, i) => {
                const input = document.getElementById(`t${i}`);
                if (input) {
                    const val = parseInput(input.value);
                    const expected = currentExample.m * x + currentExample.b;
                    if (isNaN(val) || Math.abs(val - expected) > EPSILON) {
                        allCorrect = false;
                    }
                }
            });

            feedbackElement.textContent = allCorrect ? '‚úÖ Alles richtig!' : '‚ùå Mindestens ein Wert ist falsch';
            feedbackElement.className = allCorrect ? 'feedback success' : 'feedback error';
        };

        window.checkNormal = () => {
            const mInput = document.getElementById('mInput');
            const bInput = document.getElementById('bInput');
            if (!mInput || !bInput || !feedbackElement) return;

            const m = parseInput(mInput.value);
            const b = parseInput(bInput.value);

            if (!isNaN(m) && !isNaN(b) && 
                Math.abs(m - currentExample.m) < EPSILON && 
                Math.abs(b - currentExample.b) < EPSILON) {
                feedbackElement.textContent = '‚úÖ Korrekt!';
                feedbackElement.className = 'feedback success';
            } else {
                feedbackElement.textContent = `‚ùå Richtig w√§re m = ${currentExample.m}, b = ${currentExample.b}`;
                feedbackElement.className = 'feedback error';
            }
        };

        window.checkParallel = () => {
            const pm = parseInput(document.getElementById('pm')?.value);
            const pb = parseInput(document.getElementById('pb')?.value);
            const sm = parseInput(document.getElementById('sm')?.value);
            const sb = parseInput(document.getElementById('sb')?.value);
            
            if (!feedbackElement) return;

            const parallelOK = !isNaN(pm) && !isNaN(pb) && 
                               Math.abs(pm - currentExample.m) < EPSILON && 
                               Math.abs(pb - currentExample.bPar) < EPSILON;
            
            const perpOK = !isNaN(sm) && !isNaN(sb) && 
                           (Math.abs(currentExample.m) < EPSILON ? Math.abs(sm) > 100 : Math.abs(sm - currentExample.mPerp) < EPSILON) &&
                           Math.abs(sb - currentExample.bPerp) < EPSILON;

            if (parallelOK && perpOK) {
                feedbackElement.textContent = '‚úÖ Alles richtig!';
                feedbackElement.className = 'feedback success';
            } else {
                feedbackElement.textContent = '‚ùå Nicht korrekt. √úberpr√ºfe beide Geraden.';
                feedbackElement.className = 'feedback error';
            }
        };

        window.checkGraphSelection = () => {
            if (!feedbackElement) return;
            
            if (selectedGraphIndex === -1) {
                feedbackElement.textContent = '‚ö†Ô∏è Bitte w√§hle zuerst einen Graphen aus!';
                feedbackElement.className = 'feedback warning';
                return;
            }

            showGraphSolution = true;
            
            if (selectedGraphIndex === currentExample.correctIndex) {
                feedbackElement.textContent = '‚úÖ Richtig! Das ist der passende Graph.';
                feedbackElement.className = 'feedback success';
            } else {
                feedbackElement.textContent = `‚ùå Leider falsch. Der richtige Graph ist Nummer ${currentExample.correctIndex + 1}.`;
                feedbackElement.className = 'feedback error';
            }
            
            renderSection();
        };

        window.checkZeroSteps = () => {
            const step1 = document.getElementById('step1')?.value.trim();
            const step2 = parseInput(document.getElementById('step2')?.value);
            
            if (!feedbackElement) return;

            // Schritt 1 pr√ºfen (0 = m¬∑x + b)
            const expectedStep1 = `0 = ${formatNumber(currentExample.m)}¬∑x + ${formatNumber(currentExample.b)}`;
            const step1Clean = step1?.replace(/\s+/g, '') || '';
            const expectedClean = expectedStep1.replace(/\s+/g, '');
            
            const step1OK = step1Clean === expectedClean;

            // Schritt 2 pr√ºfen (Nullstelle)
            const step2OK = !isNaN(step2) && Math.abs(step2 - currentExample.zero) < EPSILON;

            // Inputs visuell feedback geben
            const step1Input = document.getElementById('step1');
            const step2Input = document.getElementById('step2');
            
            if (step1Input) {
                step1Input.classList.toggle('input-correct', step1OK);
                step1Input.classList.toggle('input-wrong', !step1OK && step1);
            }
            
            if (step2Input) {
                step2Input.classList.toggle('input-correct', step2OK);
                step2Input.classList.toggle('input-wrong', !step2OK && step2);
            }

            if (step1OK && step2OK) {
                feedbackElement.textContent = '‚úÖ Perfekt! Beide Schritte sind richtig.';
                feedbackElement.className = 'feedback success';
            } else if (step1OK) {
                feedbackElement.textContent = '‚ö†Ô∏è Schritt 1 ist richtig, aber die Nullstelle stimmt noch nicht.';
                feedbackElement.className = 'feedback warning';
            } else {
                feedbackElement.textContent = '‚ùå Schritt 1 ist noch nicht korrekt. Setze die Funktion gleich Null.';
                feedbackElement.className = 'feedback error';
            }
        };

        window.showZeroSolution = () => {
            const step1Input = document.getElementById('step1');
            const step2Input = document.getElementById('step2');
            
            if (step1Input) {
                step1Input.value = `0 = ${formatNumber(currentExample.m)}¬∑x + ${formatNumber(currentExample.b)}`;
            }
            if (step2Input) {
                step2Input.value = formatNumber(currentExample.zero);
            }
            
            if (feedbackElement) {
                feedbackElement.textContent = 'üîç L√∂sung wurde eingef√ºgt. Vergleiche mit deiner Rechnung.';
                feedbackElement.className = 'feedback warning';
            }
        };

        // ==================== NAVIGATION ====================
        window.newExample = () => {
            generateExample();
            renderSection();
        };

        // ==================== QR CODE ====================
        window.openQR = () => {
            const overlay = document.getElementById('qrOverlay');
            const qrImg = document.getElementById('qrImage');
            if (overlay && qrImg) {
                overlay.classList.remove('hidden');
                qrImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=280x280&data=${encodeURIComponent(window.location.href)}`;
            }
        };

        window.closeQR = () => {
            document.getElementById('qrOverlay')?.classList.add('hidden');
        };

        // ==================== INITIALISIERUNG ====================
        const init = () => {
            // Navigation
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentSection = btn.dataset.section;
                    generateExample();
                    renderSection();
                });
            });

            // QR Button (nur auf GitHub Pages)
            const qrBtn = document.getElementById('qrButton');
            if (window.location.hostname.includes('github.io') || window.location.hostname.includes('localhost')) {
                qrBtn?.classList.remove('hidden');
                qrBtn?.addEventListener('click', openQR);
            }

            // Overlay schlie√üen mit Escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeQR();
                }
            });

            // Initialen State laden
            generateExample();
            renderSection();
        };

        // Start
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
</script>
</body>
</html>
