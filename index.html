<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìê Lineare Funktionen ¬∑ PRO</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg: #0c0f1c;
            --card: #1b2235;
            --card-border: #2a3450;
            --accent: #5abfff;
            --accent-soft: rgba(90, 190, 255, 0.2);
            --text: #eef3ff;
            --text-dim: #a5b3d9;
            --success: #6fcf97;
            --success-soft: rgba(111, 207, 151, 0.1);
            --error: #eb5757;
            --error-soft: rgba(235, 87, 87, 0.1);
            --radius: 20px;
            --radius-sm: 40px;
            --transition: all 0.2s ease;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.5;
            padding: 1.5rem;
            min-height: 100vh;
        }

        .app {
            max-width: 1300px;
            margin: 0 auto;
            background: #111726;
            border-radius: var(--radius);
            padding: 2rem;
            border: 1px solid var(--card-border);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .header h2 {
            font-weight: 500;
            letter-spacing: -0.01em;
        }

        .qr-btn {
            background: transparent;
            border: 1px solid var(--accent);
            padding: 0.5rem 1.2rem;
            border-radius: var(--radius-sm);
            color: white;
            cursor: pointer;
            font-size: 0.95rem;
            transition: var(--transition);
        }

        .qr-btn:hover {
            background: var(--accent-soft);
            transform: translateY(-1px);
        }

        .qr-btn:active {
            transform: translateY(0);
        }

        /* Navigation */
        .topbar {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin-bottom: 2rem;
        }

        .nav-btn {
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-dim);
            padding: 0.6rem 1.4rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.95rem;
            transition: var(--transition);
        }

        .nav-btn:hover {
            border-color: var(--accent);
            color: white;
        }

        .nav-btn.active {
            border-color: var(--accent);
            background: var(--accent-soft);
            color: white;
            font-weight: 500;
        }

        /* Hauptbereich */
        .main {
            display: grid;
            grid-template-columns: 1.2fr 0.8fr;
            gap: 2rem;
        }

        @media (max-width: 1000px) {
            .main {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--card);
            padding: 1.8rem;
            border-radius: var(--radius);
            border: 1px solid var(--card-border);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        /* SVG Container */
        .svg-container {
            background: #0f1423;
            border-radius: 16px;
            padding: 0.5rem;
            margin-bottom: 1.5rem;
        }

        svg {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 12px;
        }

        /* Erkl√§rungen */
        .explanation {
            margin-top: 1.2rem;
            font-size: 0.95rem;
            color: var(--text-dim);
        }

        .explanation b {
            color: var(--text);
            font-weight: 600;
        }

        .steps {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #cfd9ff;
            list-style: none;
            counter-reset: step-counter;
        }

        .steps li {
            margin-bottom: 0.5rem;
            counter-increment: step-counter;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .steps li::before {
            content: counter(step-counter) "Ô∏è‚É£";
            opacity: 0.8;
            font-size: 0.9rem;
        }

        .chip {
            display: inline-block;
            background: var(--accent-soft);
            padding: 0.3rem 0.8rem;
            border-radius: var(--radius-sm);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.9rem;
            border: 1px solid var(--accent);
        }

        /* Formularelemente */
        .input-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
            margin-bottom: 1rem;
        }

        input {
            background: #0f1423;
            border: 1px solid var(--card-border);
            padding: 0.6rem 1.2rem;
            border-radius: var(--radius-sm);
            color: white;
            font-size: 0.95rem;
            transition: var(--transition);
            width: 130px;
        }

        input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px var(--accent-soft);
        }

        input::placeholder {
            color: #4a5670;
        }

        .button-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin: 1.2rem 0 0.8rem;
        }

        button {
            background: var(--accent-soft);
            border: 1px solid var(--accent);
            padding: 0.6rem 1.2rem;
            border-radius: var(--radius-sm);
            color: white;
            cursor: pointer;
            font-size: 0.95rem;
            transition: var(--transition);
            flex: 0 1 auto;
        }

        button:hover {
            background: rgba(90, 190, 255, 0.3);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            border-color: var(--text-dim);
            background: transparent;
        }

        button.secondary:hover {
            border-color: white;
            background: rgba(255, 255, 255, 0.05);
        }

        /* Feedback */
        .feedback {
            margin-top: 1.2rem;
            padding: 0.8rem 1.2rem;
            border-left: 4px solid var(--accent);
            border-radius: 12px;
            background: rgba(90, 190, 255, 0.05);
            font-weight: 500;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .feedback.success {
            border-left-color: var(--success);
            background: var(--success-soft);
            color: #d0f0da;
        }

        .feedback.error {
            border-left-color: var(--error);
            background: var(--error-soft);
            color: #f5c2c2;
        }

        /* Tabelle */
        .table-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .table-label {
            min-width: 40px;
            color: var(--text-dim);
            font-family: monospace;
        }

        /* QR Overlay */
        .qr-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .qr-box {
            background: var(--card);
            padding: 2.5rem;
            border-radius: var(--radius);
            text-align: center;
            border: 1px solid var(--card-border);
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.5);
            max-width: 400px;
            width: 90%;
        }

        .qr-box h3 {
            margin-bottom: 1.5rem;
            color: var(--accent);
        }

        .qr-box img {
            margin: 1.5rem 0;
            border-radius: 12px;
            background: white;
            padding: 0.5rem;
            max-width: 100%;
            height: auto;
        }

        /* Utilities */
        .hidden {
            display: none !important;
        }

        .mt-2 {
            margin-top: 0.75rem;
        }

        .text-center {
            text-align: center;
        }
    </style>
</head>
<body>
<div class="app">
    <div class="header">
        <h2>üìê Lineare Funktionen ¬∑ PRO</h2>
        <button class="qr-btn hidden" id="qrButton">üì± QR-Code</button>
    </div>

    <div class="topbar">
        <button class="nav-btn active" data-section="coords">üìå Punkte</button>
        <button class="nav-btn" data-section="table">üìä Tabelle</button>
        <button class="nav-btn" data-section="normal">üìà m & b</button>
        <button class="nav-btn" data-section="parallel">‚ö° Parallel</button>
    </div>

    <div class="main">
        <div class="card" id="graphCard"></div>
        <div class="card" id="exerciseCard"></div>
    </div>
</div>

<div id="qrOverlay" class="qr-overlay hidden">
    <div class="qr-box">
        <h3>üì± Auf Smartphone √∂ffnen</h3>
        <img id="qrImage" alt="QR-Code">
        <div class="button-group" style="justify-content: center;">
            <button onclick="closeQR()">Schlie√üen</button>
        </div>
    </div>
</div>

<script>
    (function() {
        'use strict';

        // ==================== KONSTANTEN & HILFSFUNKTIONEN ====================
        const SVG_BOUNDS = { min: -6, max: 6 };
        const EPSILON = 0.01;

        const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        
        const randomSlope = () => {
            let m;
            do {
                m = randomInt(-4, 4);
            } while (Math.abs(m) < EPSILON);
            return m;
        };

        const parseInput = (val) => {
            if (!val) return NaN;
            const str = val.replace(/,/g, '.').trim();
            
            // Bruch parsing
            if (str.includes('/')) {
                const parts = str.split('/').map(Number);
                if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1]) && Math.abs(parts[1]) > EPSILON) {
                    return parts[0] / parts[1];
                }
            }
            
            const num = parseFloat(str);
            return isNaN(num) ? NaN : num;
        };

        // ==================== SVG RENDERING ====================
        const clipLine = (m, b) => {
            const { min: xMin, max: xMax } = SVG_BOUNDS;
            const yMin = xMin, yMax = xMax;
            const points = [];
            
            const addPoint = (x, y) => {
                if (x >= xMin - EPSILON && x <= xMax + EPSILON && 
                    y >= yMin - EPSILON && y <= yMax + EPSILON) {
                    points.push({ x: Math.max(xMin, Math.min(xMax, x)), 
                                 y: Math.max(yMin, Math.min(yMax, y)) });
                }
            };

            // Endpunkte an den R√§ndern
            addPoint(xMin, m * xMin + b);
            addPoint(xMax, m * xMax + b);

            // Schnittpunkte mit den R√§ndern
            if (Math.abs(m) > EPSILON) {
                addPoint((yMin - b) / m, yMin);
                addPoint((yMax - b) / m, yMax);
            }

            // Deduplizieren und auf 2 Punkte begrenzen
            return points.slice(0, 2);
        };

        const renderSVG = (m, b, options = {}) => {
            const { triangle = false, highlight = null } = options;
            const { min, max } = SVG_BOUNDS;
            const range = max - min;
            
            let gridLines = '';
            
            // Gitterlinien
            for (let x = min; x <= max; x++) {
                if (x === 0) continue; // Achsen separat
                gridLines += `<line x1="${x}" y1="${min}" x2="${x}" y2="${max}" stroke="#2a3450" stroke-width="0.05"/>`;
            }
            for (let y = min; y <= max; y++) {
                if (y === 0) continue;
                gridLines += `<line x1="${min}" y1="${y}" x2="${max}" y2="${y}" stroke="#2a3450" stroke-width="0.05"/>`;
            }

            // Achsen
            const axes = `
                <line x1="${min}" y1="0" x2="${max}" y2="0" stroke="#5abfff" stroke-width="0.12"/>
                <line x1="0" y1="${min}" x2="0" y2="${max}" stroke="#5abfff" stroke-width="0.12"/>
            `;

            // Funktionslinie
            let functionLine = '';
            if (m !== null && !isNaN(m) && !isNaN(b)) {
                const segment = clipLine(m, b);
                if (segment.length === 2) {
                    functionLine = `<line x1="${segment[0].x}" y1="${segment[0].y}" 
                                           x2="${segment[1].x}" y2="${segment[1].y}" 
                                           stroke="#5abfff" stroke-width="0.2" stroke-linecap="round"/>`;
                }
            }

            // Steigungsdreieck
            let triangleMark = '';
            if (triangle && m !== null && !isNaN(m) && !isNaN(b) && Math.abs(m) < 10) {
                const run = 1;
                const rise = m;
                const p1 = { x: 0, y: b };
                const p2 = { x: run, y: b };
                const p3 = { x: run, y: b + rise };
                
                // Nur zeichnen wenn im sichtbaren Bereich
                if (Math.abs(p1.x) <= max && Math.abs(p1.y) <= max &&
                    Math.abs(p2.x) <= max && Math.abs(p2.y) <= max &&
                    Math.abs(p3.x) <= max && Math.abs(p3.y) <= max) {
                    triangleMark = `
                        <polygon points="${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}"
                                 fill="rgba(90,190,255,0.2)" stroke="#5abfff" stroke-width="0.1" stroke-dasharray="0.2"/>
                    `;
                }
            }

            // Hervorhebung
            let highlightMark = '';
            if (highlight) {
                highlightMark = `<circle cx="${highlight.x}" cy="${highlight.y}" r="0.35" fill="#eb5757" stroke="white" stroke-width="0.1"/>`;
            }

            // Zahlen an den Achsen (einfach)
            let labels = '';
            for (let i = min; i <= max; i++) {
                if (i === 0) continue;
                labels += `<text x="${i - 0.2}" y="-0.2" fill="#6b7b9c" font-size="0.3">${i}</text>`;
                labels += `<text x="-0.4" y="${i + 0.1}" fill="#6b7b9c" font-size="0.3">${-i}</text>`;
            }

            return `
                <div class="svg-container">
                    <svg viewBox="${min} ${min} ${range} ${range}" xmlns="http://www.w3.org/2000/svg">
                        ${gridLines}
                        ${axes}
                        ${labels}
                        ${functionLine}
                        ${triangleMark}
                        ${highlightMark}
                    </svg>
                </div>
            `;
        };

        // ==================== APP STATE ====================
        let currentSection = 'coords';
        let currentExample = {};
        let feedbackElement = null;

        // ==================== BEISPIELE GENERIEREN ====================
        const generateExample = () => {
            switch (currentSection) {
                case 'coords':
                    currentExample = {
                        target: {
                            x: randomInt(-5, 5),
                            y: randomInt(-5, 5)
                        }
                    };
                    break;

                case 'table':
                    currentExample = {
                        m: randomSlope(),
                        b: randomInt(-4, 4),
                        xs: [-2, -1, 0, 1, 2]
                    };
                    break;

                case 'normal':
                    currentExample = {
                        m: randomSlope(),
                        b: randomInt(-4, 4)
                    };
                    break;

                case 'parallel':
                    const m = randomSlope();
                    const b = randomInt(-4, 4);
                    const P = {
                        x: randomInt(-3, 3),
                        y: randomInt(-3, 3)
                    };
                    const mPerp = (Math.abs(m) < EPSILON) ? 1000 : -1 / m; // Vertikal bei m=0
                    
                    currentExample = {
                        m, b, P,
                        mPerp,
                        bPar: P.y - m * P.x,
                        bPerp: P.y - mPerp * P.x
                    };
                    break;
            }
        };

        // ==================== UI RENDERING ====================
        const renderSection = () => {
            const graphCard = document.getElementById('graphCard');
            const exerciseCard = document.getElementById('exerciseCard');
            
            if (!graphCard || !exerciseCard) return;

            // Graph Card immer zuerst rendern
            let graphHTML = '';
            let exerciseHTML = '';

            switch (currentSection) {
                case 'coords':
                    graphHTML = renderSVG(null, null, { highlight: currentExample.target });
                    graphHTML += `
                        <div class="explanation">
                            <b>üìå Punkt im Koordinatensystem</b>
                            <p>Koordinaten: (x | y) ‚Äî zuerst x, dann y.</p>
                            <ul class="steps">
                                <li>Vom Ursprung starten</li>
                                <li>Nach rechts/links (x)</li>
                                <li>Nach oben/unten (y)</li>
                            </ul>
                        </div>
                    `;

                    exerciseHTML = `
                        <div class="input-group">
                            <input id="coordsInput" placeholder="x, y" autocomplete="off">
                        </div>
                        <div class="button-group">
                            <button onclick="checkCoords()">‚úì Pr√ºfen</button>
                            <button class="secondary" onclick="newExample()">‚Üª Neu</button>
                        </div>
                        <div class="feedback" id="feedback"></div>
                    `;
                    break;

                case 'table':
                    graphHTML = renderSVG(currentExample.m, currentExample.b);
                    graphHTML += `
                        <div class="explanation">
                            <b>üìä Wertetabelle</b>
                            <p>Formel: <span class="chip">y = m¬∑x + b</span></p>
                            <ul class="steps">
                                <li>x einsetzen</li>
                                <li>m¬∑x berechnen</li>
                                <li>b addieren</li>
                            </ul>
                        </div>
                    `;

                    exerciseHTML = '<div style="margin-bottom: 1rem;">';
                    currentExample.xs.forEach((x, i) => {
                        exerciseHTML += `
                            <div class="table-row">
                                <span class="table-label">x = ${x}</span>
                                <input id="t${i}" placeholder="y" autocomplete="off">
                            </div>
                        `;
                    });
                    exerciseHTML += `</div>
                        <div class="button-group">
                            <button onclick="checkTable()">‚úì Pr√ºfen</button>
                            <button class="secondary" onclick="newExample()">‚Üª Neu</button>
                        </div>
                        <div class="feedback" id="feedback"></div>
                    `;
                    break;

                case 'normal':
                    graphHTML = renderSVG(currentExample.m, currentExample.b, { triangle: true });
                    graphHTML += `
                        <div class="explanation">
                            <b>üìà Steigung & Achsenabschnitt</b>
                            <p><span class="chip">b</span> = Schnittpunkt mit y-Achse</p>
                            <p><span class="chip">m</span> = Anstieg (Œîy / Œîx)</p>
                        </div>
                    `;

                    exerciseHTML = `
                        <div class="input-group">
                            <input id="mInput" placeholder="m" autocomplete="off">
                            <input id="bInput" placeholder="b" autocomplete="off">
                        </div>
                        <div class="button-group">
                            <button onclick="checkNormal()">‚úì Pr√ºfen</button>
                            <button class="secondary" onclick="newExample()">‚Üª Neu</button>
                        </div>
                        <div class="feedback" id="feedback"></div>
                    `;
                    break;

                case 'parallel':
                    graphHTML = renderSVG(currentExample.m, currentExample.b, { highlight: currentExample.P });
                    graphHTML += `
                        <div class="explanation">
                            <b>‚ö° Parallele & Senkrechte</b>
                            <p>Parallel: gleiche Steigung m</p>
                            <p>Senkrecht: m‚ÇÅ ¬∑ m‚ÇÇ = -1</p>
                            <p>Punkt P (rot) liegt auf beiden Geraden</p>
                        </div>
                    `;

                    exerciseHTML = `
                        <div style="margin-bottom: 1rem;">
                            <div class="input-group">
                                <span style="min-width: 80px;">Parallel m:</span>
                                <input id="pm" placeholder="m" autocomplete="off">
                            </div>
                            <div class="input-group">
                                <span style="min-width: 80px;">Parallel b:</span>
                                <input id="pb" placeholder="b" autocomplete="off">
                            </div>
                            <div class="input-group mt-2">
                                <span style="min-width: 80px;">Senkrecht m:</span>
                                <input id="sm" placeholder="m" autocomplete="off">
                            </div>
                            <div class="input-group">
                                <span style="min-width: 80px;">Senkrecht b:</span>
                                <input id="sb" placeholder="b" autocomplete="off">
                            </div>
                        </div>
                        <div class="button-group">
                            <button onclick="checkParallel()">‚úì Pr√ºfen</button>
                            <button class="secondary" onclick="newExample()">‚Üª Neu</button>
                        </div>
                        <div class="feedback" id="feedback"></div>
                    `;
                    break;
            }

            graphCard.innerHTML = graphHTML;
            exerciseCard.innerHTML = exerciseHTML;
            feedbackElement = document.getElementById('feedback');
        };

        // ==================== PR√úFFUNKTIONEN ====================
        window.checkCoords = () => {
            const input = document.getElementById('coordsInput');
            if (!input || !feedbackElement) return;
            
            const parts = input.value.split(',').map(Number);
            const isValid = parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1]);
            
            if (isValid && parts[0] === currentExample.target.x && parts[1] === currentExample.target.y) {
                feedbackElement.textContent = '‚úÖ Richtig! Gut gemacht!';
                feedbackElement.className = 'feedback success';
            } else {
                feedbackElement.textContent = `‚ùå Gesucht war (${currentExample.target.x} | ${currentExample.target.y})`;
                feedbackElement.className = 'feedback error';
            }
        };

        window.checkTable = () => {
            if (!feedbackElement || !currentExample.xs) return;
            
            let allCorrect = true;
            currentExample.xs.forEach((x, i) => {
                const input = document.getElementById(`t${i}`);
                if (input) {
                    const val = parseInput(input.value);
                    const expected = currentExample.m * x + currentExample.b;
                    if (isNaN(val) || Math.abs(val - expected) > EPSILON) {
                        allCorrect = false;
                    }
                }
            });

            feedbackElement.textContent = allCorrect ? '‚úÖ Alles richtig!' : '‚ùå Mindestens ein Wert ist falsch';
            feedbackElement.className = allCorrect ? 'feedback success' : 'feedback error';
        };

        window.checkNormal = () => {
            const mInput = document.getElementById('mInput');
            const bInput = document.getElementById('bInput');
            if (!mInput || !bInput || !feedbackElement) return;

            const m = parseInput(mInput.value);
            const b = parseInput(bInput.value);

            if (!isNaN(m) && !isNaN(b) && 
                Math.abs(m - currentExample.m) < EPSILON && 
                Math.abs(b - currentExample.b) < EPSILON) {
                feedbackElement.textContent = '‚úÖ Korrekt!';
                feedbackElement.className = 'feedback success';
            } else {
                feedbackElement.textContent = `‚ùå Richtig w√§re m = ${currentExample.m}, b = ${currentExample.b}`;
                feedbackElement.className = 'feedback error';
            }
        };

        window.checkParallel = () => {
            const pm = parseInput(document.getElementById('pm')?.value);
            const pb = parseInput(document.getElementById('pb')?.value);
            const sm = parseInput(document.getElementById('sm')?.value);
            const sb = parseInput(document.getElementById('sb')?.value);
            
            if (!feedbackElement) return;

            const parallelOK = !isNaN(pm) && !isNaN(pb) && 
                               Math.abs(pm - currentExample.m) < EPSILON && 
                               Math.abs(pb - currentExample.bPar) < EPSILON;
            
            const perpOK = !isNaN(sm) && !isNaN(sb) && 
                           (Math.abs(currentExample.m) < EPSILON ? Math.abs(sm) > 100 : Math.abs(sm - currentExample.mPerp) < EPSILON) &&
                           Math.abs(sb - currentExample.bPerp) < EPSILON;

            if (parallelOK && perpOK) {
                feedbackElement.textContent = '‚úÖ Alles richtig!';
                feedbackElement.className = 'feedback success';
            } else {
                feedbackElement.textContent = '‚ùå Nicht korrekt. √úberpr√ºfe beide Geraden.';
                feedbackElement.className = 'feedback error';
            }
        };

        // ==================== NAVIGATION ====================
        window.newExample = () => {
            generateExample();
            renderSection();
        };

        // ==================== QR CODE ====================
        window.openQR = () => {
            const overlay = document.getElementById('qrOverlay');
            const qrImg = document.getElementById('qrImage');
            if (overlay && qrImg) {
                overlay.classList.remove('hidden');
                qrImg.src = `https://api.qrserver.com/v1/create-qr-code/?size=280x280&data=${encodeURIComponent(window.location.href)}`;
            }
        };

        window.closeQR = () => {
            document.getElementById('qrOverlay')?.classList.add('hidden');
        };

        // ==================== INITIALISIERUNG ====================
        const init = () => {
            // Navigation
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentSection = btn.dataset.section;
                    generateExample();
                    renderSection();
                });
            });

            // QR Button (nur auf GitHub Pages)
            const qrBtn = document.getElementById('qrButton');
            if (window.location.hostname.includes('github.io') || window.location.hostname.includes('localhost')) {
                qrBtn?.classList.remove('hidden');
                qrBtn?.addEventListener('click', openQR);
            }

            // Overlay schlie√üen mit Escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeQR();
                }
            });

            // Initialen State laden
            generateExample();
            renderSection();
        };

        // Start
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
</script>
</body>
</html>
